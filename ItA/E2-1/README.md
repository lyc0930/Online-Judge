# E2-1 数据库查询v2
## 题目描述
勤奋的小明为了预习下学期的数据库课程，决定亲自实现一个简单的数据库系统。该数据库系统需要处理用户的数据库插入和查询语句，并输出相应的输出。具体来说，用户的输入共包含若干条插入语句和查询语句。其中每条插入语句包含一个非负整数表示需要插入的数据。每条查询语句包含一个整数表示待查询的键值，若该键值存在则直接输出该键值，否则输出数据库中比该键值小的最大键值

## 输入格式
首先是若干行插入或查询语句，每行的格式为如下的一种：

INSERT $key$

FIND $key$

最后单独的一行

EXIT

表示输入结束。

## 输出格式
对每条查询语句输出一行，每行输出一个数字，表示查询的结果。

该键值存在则直接输出该键值，否则输出数据库中比该键值小的最大键值

## 数据规模：

插入语句和查询语句一共不超过$2 \times 10^6$条。

$0\leq key \leq 10^9$



# 解题报告

## 初始思路
相比起实验1中的数据库查询v1，本题中的变化主要体现为：

1. 数据仅为键值
2. 插入与查询语句混输
3. 当键值不存在时输出数据库中比该键值小的最大键值

综合1和3两点变化，再使用以键值对查询、分散存储的Hash表就不再合适了，注意到2和3两点变化，考虑使用BST来实现。

为提升程序效率，最终采用红黑树实现本题，需要支持的操作有插入与查询。注意到其中查询操作在失败时应当返回数据库中比该键值小的最大键值，故还需实现查找结点的直接前驱。

插入与查找的算法不再赘述，在实现返回数据库中比$key$小的最大键值时，初始思路是在查找过程中当遇到与“期望的大小关系”相反的结点即停止查找并返回小于$key$值的结点。
## 提交与修改过程
初次提交随即[WA](https://202.38.86.171/status/cfaf2e9f3afef96e42e8f064bcca0640)，重新审视上述对于查找失败的处理，显然是不合理的，这和直接前驱有着很大区别。对于一般情况，直接前驱应当是某结点左子树中的最大值，若此节点没有左孩子，则其直接前驱应当向上检索一个结点使得此节点是其右子树的成员。
```c
Node *RB_Predecessor(Tree *T, Node *x)
{
    if (x->left == T->nil) // x没有左孩子
    {
        while (x->parent != T->nil && x->parent->left == x) // 向上查找直到x是某个结点的右子树的成员
            x = x->parent;
        x = x->parent;
    }
    else
    {
        x = x->left; // 直接前驱是x左子树中的最大值
        while (x->right!=T->nil)
        {
            x=x->right;
        }
    }
    return x;
}
```
对于不存在于树中的$key$值，修改查找算法，使得当查找到哨兵`T.nil`时，返回合适的结点以满足小于$key$且最大。事实上，在这种情况下，`RB_Predecessor`中`if`条件一定成立，只会执行`then`语句块。
```c
Node *RB_Search_Alternative(Tree *T, Type key)
{
    Node *node = T->root;
    while ((node != T->nil) && (node->key != key))
    {
        if (key < node->key)
        {
            if (node->left != T->nil)
                node = node->left;
            else // 没有再比node小的结点了
            {
                node = RB_Predecessor(T, node); // 返回node的直接前驱
                break;
            }
        }
        else
        {
            if (node->right != T->nil) // 没有再比node大的结点
                node = node->right; // node即满足要求
            else
                break;
        }
    }
    return node;
}
```
修改代码如上后再次提交，[AC](https://202.38.86.171/status/88fd6ede5808fcb1df4d047b17d3d140)，耗时816ms，内存占用38MB。

## 算法分析
### 时间复杂度
本题的算法基于红黑树的结构，实现了插入（包括`RB_Insert`、`RB_Insert_Fixup`），查询（包括`RB_Search_Alternative`和`RB_Predecessor`）以及一些常数时间的如建树等操作。
- 插入：`RB_Insert`与`RB_Insert_Fixup`均耗时$O(\lg{n})$的时间，因此一个插入命令消耗的时间是$O(\lg{n})$，其中$n$是数据库中的条目数
- 查询：若没有发生向左孩子方向查找到哨兵`T.nil`，触发查找直接前驱的情况，则消耗的渐进时间是$O(\lg{n})$；如果查找直接前驱，如前所述，在这种情况下，`RB_Predecessor`中`if`条件一定成立，只会执行向上查找直到结点是某个右子树的成员，这部分消耗$O(\lg{n})$的时间，因此查询命令消耗的时间也为$O(\lg{n})$
### 空间复杂度
因为每一条插入指令会在红黑树中插入一个结点，因此算法的空间复杂度是$O(n_i)$，其中$n_i$是总的插入语句数量。
## 总结
本题不涉及数据条目的删除，仅涉及插入与查询操作，是一道较为简单的BST模板题。若不考虑模板化数据结构，也可以将计算直接前驱的函数拆分合并到查询函数中以进一步优化。